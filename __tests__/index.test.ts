import ExMath from '../src/index'

describe('Original Math Test', () => {
  it('Getter Test', () => {
    expect(ExMath.E).toBe(Math.E)
    expect(ExMath.LN2).toBe(Math.LN2)
    expect(ExMath.LN10).toBe(Math.LN10)
    expect(ExMath.LOG2E).toBe(Math.LOG2E)
    expect(ExMath.LOG10E).toBe(Math.LOG10E)
    expect(ExMath.PI).toBe(Math.PI)
    expect(ExMath.SQRT1_2).toBe(Math.SQRT1_2)
    expect(ExMath.SQRT2).toBe(Math.SQRT2)
  })
  it('Function Test', () => {
    expect(ExMath.abs(1.23)).toBe(Math.abs(1.23))
    expect(ExMath.acos(1.23)).toBe(Math.acos(1.23))
    expect(ExMath.acosh(1.23)).toBe(Math.acosh(1.23))
    expect(ExMath.asin(1.23)).toBe(Math.asin(1.23))
    expect(ExMath.asinh(1.23)).toBe(Math.asinh(1.23))
    expect(ExMath.atan(1.23)).toBe(Math.atan(1.23))
    expect(ExMath.atanh(1.23)).toBe(Math.atanh(1.23))
    expect(ExMath.atan2(1.23, 2.34)).toBe(Math.atan2(1.23, 2.34))
    expect(ExMath.cbrt(1.23)).toBe(Math.cbrt(1.23))
    expect(ExMath.ceil(1.23)).toBe(Math.ceil(1.23))
    expect(ExMath.clz32(1.23)).toBe(Math.clz32(1.23))
    expect(ExMath.cos(1.23)).toBe(Math.cos(1.23))
    expect(ExMath.cosh(1.23)).toBe(Math.cosh(1.23))
    expect(ExMath.exp(1.23)).toBe(Math.exp(1.23))
    expect(ExMath.expm1(1.23)).toBe(Math.expm1(1.23))
    expect(ExMath.floor(1.23)).toBe(Math.floor(1.23))
    expect(ExMath.fround(1.23)).toBe(Math.fround(1.23))
    expect(ExMath.hypot(1.23, 2.34)).toBe(Math.hypot(1.23, 2.34))
    expect(ExMath.imul(1.23, 2.34)).toBe(Math.imul(1.23, 2.34))
    expect(ExMath.log(1.23)).toBe(Math.log(1.23))
    expect(ExMath.log1p(1.23)).toBe(Math.log1p(1.23))
    expect(ExMath.log10(1.23)).toBe(Math.log10(1.23))
    expect(ExMath.log2(1.23)).toBe(Math.log2(1.23))
    expect(ExMath.max(1.23, 2.34)).toBe(Math.max(1.23, 2.34))
    expect(ExMath.min(1.23, 2.34)).toBe(Math.min(1.23, 2.34))
    expect(ExMath.pow(1.23, 2.34)).toBe(Math.pow(1.23, 2.34))
    const spy = jest.spyOn(global.Math, 'random')
    spy.mockReturnValue(123456)
    expect(ExMath.random()).toBe(Math.random())
    spy.mockRestore()
    expect(ExMath.round(1.23)).toBe(Math.round(1.23))
    expect(ExMath.sign(1.23)).toBe(Math.sign(1.23))
    expect(ExMath.sin(1.23)).toBe(Math.sin(1.23))
    expect(ExMath.sinh(1.23)).toBe(Math.sinh(1.23))
    expect(ExMath.sqrt(1.23)).toBe(Math.sqrt(1.23))
    expect(ExMath.tan(1.23)).toBe(Math.tan(1.23))
    expect(ExMath.tanh(1.23)).toBe(Math.tanh(1.23))
    expect(ExMath.trunc(1.23)).toBe(Math.trunc(1.23))
  })
})

describe('Extension Math Test', () => {
  const checkAry = (src: number[], dst: number[]) => {
    expect(src.length).toBe(dst.length)
    for (let i = 0; i < src.length; i++) {
      expect(src[i]).toBeCloseTo(dst[i])
    }
  }
  it('Function Test', () => {
    expect(ExMath.sum(1, 2, 3, 4)).toBe(10)
    expect(ExMath.average(1, 2, 3, 4)).toBe(2.5)
    expect(ExMath.factorial(3)).toBe(6)
    expect(ExMath.permutation(4, 2)).toBe(12)
    expect(ExMath.combination(4, 2)).toBe(6)
    checkAry(ExMath.rotate2d(Math.PI / 2, 100, 0), [0, 100])
    checkAry(ExMath.rotate2d(Math.PI / 2, 200, 100, 100, 100), [100, 200])
    checkAry(ExMath.rotate3d('x', Math.PI / 2, 0, 100, 0), [0, 0, 100])
    checkAry(ExMath.rotate3d('x', Math.PI / 2, 100, 200, 100, 100, 100, 100), [100, 100, 200])
    checkAry(ExMath.rotate3d('y', Math.PI / 2, 0, 0, 100), [100, 0, 0])
    checkAry(ExMath.rotate3d('y', Math.PI / 2, 100, 100, 200, 100, 100, 100), [200, 100, 100])
    checkAry(ExMath.rotate3d('z', Math.PI / 2, 100, 0, 0), [0, 100, 0])
    checkAry(ExMath.rotate3d('z', Math.PI / 2, 200, 100, 100, 100, 100, 100), [100, 200, 100])
  })
})